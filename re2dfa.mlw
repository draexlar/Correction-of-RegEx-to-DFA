module BasicTypes

  use seq.Seq, list.List

  type char

  val eq (c1 c2: char) : bool
    ensures { result <-> c1 = c2 }

  val constant eps : char (* used for representing the empty transitions *)

   (* defining input symbols and alphabet *)
  type symbol = char

  clone import set.SetApp as SA with type elt = symbol

  (* defining word and language as a set *)
  type word = list symbol

  clone import set.SetApp as SL with type elt = word

  (* defining a state and a set of states *)
  type state = int

  clone import set.SetApp as SS with type elt = state

  (* defining a transition and a set of transitions *)
  type transition = (state , symbol , state)

  clone import set.SetApp as ST with type elt = transition

end


module RegEx

  use BasicTypes
  use list.List

  (* representation of regular expressions *)
  type regex =
      Empty
    | Eps
    | Symb symbol
    (*| Seq regex regex
    | Plus regex regex*)

  use set.Fset

  (* function that returns the language of a given regular expression r *)
  function regexLang (r: regex) : fset word =
    match r with
    | Empty -> empty
    | Eps -> add (Cons eps Nil) empty
    | Symb a -> add (Cons a Nil) empty
    (*| Seq e f -> let l = regexLang e in
                      SL.iter (fun w -> SL.add w l) Language.add (regexLang f)
    | Plus (e, f) -> Language.union (regexLang f) (regexLang e) <<r*)
   end

end


module NFA

  use BasicTypes, RegEx, ref.Ref
  use import list.Mem as LM
  use int.Int
  use set.Fset
  use list.List, list.Length
 
  val constant start_const: state

  (* representation of a finite automaton *)
  type automaton = {
    states: SS.set;
    alphabet: SA.set;
    start: state;
    transitions: ST.set;
    finalStates: SS.set;
  } invariant { mem start states }
    invariant { not (is_empty states) }
    invariant { subset finalStates states }
    invariant { forall t: transition. mem t transitions ->
                  let (a,b,c) = t in mem a states /\ mem b (add eps alphabet) /\ mem c states }
    by { states = SS.singleton start_const; alphabet = SA.empty ();
         start = start_const; transitions = ST.empty (); finalStates = SS.empty () }

  (* --- Operations over finite automatons --- *)

  (* returns a set of states obtained by the first projection of each transition in the set t  *)
  let rec ghost function delta_get_1st (t: fset transition) : fset state 
    variant { cardinal t }
    ensures { forall x. mem x result -> exists b c. mem (x, b, c) t }
    ensures { forall a, b, c. mem (a, b, c) t -> mem a result }
  =
    if is_empty t then empty
    else let elem = pick t in
         let (a,_,_) = elem in
           add a (delta_get_1st (remove elem t))
    
  (* returns a set of symbols obtained by the second projection of each transition in the set t  *)
  let rec ghost function delta_get_2nd (t: fset transition) : fset symbol
    variant { cardinal t }
    ensures { forall x. mem x result -> exists a c. mem (a, x, c) t }
    ensures { forall a, b, c. mem (a, b, c) t -> mem b result }
  =
    if is_empty t then empty
    else let elem = pick t in
         let (_,b,_) = elem in
           add b (delta_get_2nd (remove elem t))

  (* returns a set os states obtained by the third projection of each transition in the set t  *)
  let rec ghost function delta_get_3rd (t: fset transition) : fset state
    variant { cardinal t }
    ensures { forall x. mem x result -> exists a b. mem (a, b, x) t }
    ensures { forall a, b, c. mem (a, b, c) t -> mem c result }
  =
    if is_empty t then empty
    else let elem = pick t in
         let (_,_,c) = elem in
           add c (delta_get_3rd (remove elem t))
  
  
  (* returns all transitions in t begining in state s and computed by symbol sym *)
  let rec ghost function filter_trans (s: state) (sym: symbol) (t: fset transition) :
    fset transition
    variant { cardinal t }
    ensures { subset result t }
    ensures { forall a, b, c. mem (a, b, c) result -> b = sym /\ a = s }
    ensures { forall c. mem (s, sym, c) t -> mem (s, sym, c) result }
  =
    if is_empty t then empty
    else let elem = pick t in
      let (a,b,_) = elem in
      if s = a && eq b sym then
        add elem (filter_trans s sym (remove elem t))
      else filter_trans s sym (remove elem t)

  (* obtains the next states computed through epsilon transitions from each state in s *)
  let rec ghost function fold_next_states (s: fset state) (a: automaton) : fset state
    requires { subset s a.states }
    variant  { cardinal s }
    ensures  { subset result a.states }
    ensures  { subset s result }
    ensures  { forall q. mem q result -> mem q s \/ (exists i. mem i result /\ mem (i, eps, q) a.transitions) }
    ensures  { forall i, q. mem i s /\ mem (i, eps, q) a.transitions -> mem q result }
  =
    if is_empty s then empty
    else let q = pick s in
         let t = BasicTypes.ST.to_fset a.transitions in
         let trans = filter_trans q eps t in
         let nxt_sts = add q (delta_get_3rd trans) in
           union nxt_sts (fold_next_states (remove q s) a)

  use int.Power
  
  (* computes the epsilone-closure for each state in s *)
  let rec ghost function eclose (s: fset state) (a: automaton) : fset state
    requires { subset s a.states }
    variant  { cardinal a.states - cardinal s }
    ensures  { subset result a.states }
    ensures  { subset s result }
    ensures  { forall q. mem q result -> mem q s \/ (exists i. mem i result /\ mem (i, eps, q) a.transitions)  }
    ensures  { forall i, q. mem i result /\ mem (i, eps, q) a.transitions -> mem q result }
    ensures  { is_empty a.transitions -> result = s }
  =
    let t = BasicTypes.ST.to_fset a.transitions in
    if is_empty t then s
    else let ns = fold_next_states s a in
         if subset ns s then ns 
         else eclose (union s ns) a

  (* returns states reachable from s through sym *)
  let ghost function delta (s: state) (sym: symbol) (a: automaton) : fset state
    requires { mem s a.states }
    ensures  { subset result a.states }
    ensures { forall c. mem (s, sym, c) a.transitions <-> mem c result }
  =
    let t = BasicTypes.ST.to_fset a.transitions in
    let trans = filter_trans s sym t in
      delta_get_3rd trans

  (* for each state in s, computes its transition through sym *)
  let rec ghost function fold_delta (s: fset state) (sym: symbol) (a: automaton) : fset state
    requires { subset s a.states }
    variant  { cardinal s }
    ensures  { subset result a.states }
    ensures  { forall c. mem c result -> exists q. mem q s /\ mem (q, sym, c) a.transitions }
    ensures  { forall q, c. mem q s /\ mem (q, sym, c) a.transitions -> mem c result }
  =
    if is_empty s then empty
    else let st = pick s in
         let ds = delta st sym a in
         union ds (fold_delta (remove st s) sym a)


  (* determines if there is a path from s to f, through a word w *)    
  predicate path (s: state) (w: word) (f: state) (a: automaton) 
  =
    mem s a.states ->
    match w with
    | Nil -> s = f \/ mem (s, eps, f) a.transitions
    | Cons x Nil -> mem x (add eps a.alphabet) /\
                    if x = eps then s = f \/ mem (s, x, f) a.transitions
                    else mem (s, x, f) a.transitions
    | Cons x xs -> mem x (add eps a.alphabet) /\
                   exists r. mem (r, x, f) a.transitions /\ path s xs r a
    end

  (* extended transition function: returns the set of states reachable from s trhough a word s *)
  let rec ghost function delta_ext (s: state) (w: word) (a: automaton) :
    fset state
    requires { mem s a.states }
    requires { forall x. LM.mem x w -> mem x (add eps a.alphabet) }
    variant  { length w }
    ensures  { subset result a.states }
    ensures  { forall r. path s w r a -> mem r result }
    (*ensures  { forall r. mem r result -> (s = r /\ not (path s w r a)) \/ path s w r a }*)
  =
      match w with
      | Nil -> eclose (add s empty) a
      | Cons x Nil -> if eq x eps then eclose (add s empty) a
                      else let rs = delta_ext s Nil a in
                           let qs = fold_delta rs x a in
                             eclose qs a
      | Cons x xs ->  let rs = delta_ext s xs a in
                      let qs = fold_delta rs x a in
                        eclose qs a
      end


  (* --- Compile automaton --- *)

  type gen_sym = {
    mutable r: int;
    ghost mutable dom: fset int
  }

  let c: gen_sym = { r = 0; dom = empty }

  val next_val (g: gen_sym) : int
    writes  { g }
    ensures { not (mem result (old g).dom) }
    ensures { g.r = (old g).r + 1 }
    ensures { g.dom == add result (old g).dom }
  (* = g.r <- g.r + 1; g.dom <- add g.r g.dom; g.r *)

  (* TODO: delete later *)
  (*axiom delta_ext_eps: forall i a.
    delta_ext i (Cons eps Nil) a = add a.start a.finalStates*)

  (* axiom delta_ext_symb: forall i a l. *)
  (*   delta_ext i l a = add a.start a.finalStates *)

  (* alphabet closure *)
  function sigma_ext (ss: fset symbol) : fset word =
    let ss = map (fun s -> Cons s Nil) ss in
    add (Cons eps Nil) ss

  (* computes the language of a given automaton *)
  function automatonLang (a: automaton) : fset word =
    let p = fun w -> inter (delta_ext a.start w a) a.finalStates <> empty in
    filter (sigma_ext a.alphabet) p
  
  (* constructive definition of the language of an automaton *)
  let ghost function automatonLangConstr (a: automaton) : fset word
  =
    let t = BasicTypes.ST.to_fset a.transitions in
    let finals = BasicTypes.SS.to_fset a.finalStates in
    let emp: fset word = BasicTypes.SL.to_fset (BasicTypes.SL.empty ()) in 
    if is_empty t then
      if is_empty finals then emp
      else if mem a.start finals then singleton (Cons eps Nil)
      else emp
    else if cardinal t = 1 then
      let (_, x, _) = pick t in
        singleton (Cons x Nil)
    else emp
    
  (*lemma aux: forall s w a.
    mem w (sigma_ext a.alphabet) /\ mem s a.states ->
      match w with
      | Nil -> true
      | Cons x _ -> exists q. mem (s, x, q) a.transitions
      end*)

  (*lemma langLength1:
    forall a: automaton, f: state, sym: symbol.
      mem f a.finalStates /\ a.transitions = singleton (a.start, sym, f) ->
      automatonLang a = singleton (Cons sym Nil)*)
      
  (*lemma langContains:
    forall a: automaton, f: state, sym: symbol.
      mem f a.finalStates /\ mem sym a.alphabet /\ subset (singleton (a.start, sym, f)) (a.transitions) ->
      subset (singleton (Cons sym Nil)) (automatonLang a)*)

  (* computes the equivalent finite automaton of a given regular expression r *)
  let compile (r: regex) : automaton
    ensures { regexLang r = automatonLangConstr result }
  = match r with
    | Empty -> let i = next_val c in
        { states = SS.add i (SS.empty ());
          alphabet = SA.empty ();
          start = i;
          transitions = ST.empty ();
          finalStates = SS.empty (); }
    | Eps -> let start = next_val c in
        let final = next_val c in
        let states = SS.add start (SS.empty ()) in
        let states = SS.add final states in
        let r = { states = states;
          alphabet = SA.empty ();
          start = start;
          transitions = ST.add (start, eps, final) (ST.empty ());
          finalStates = SS.add final (SS.empty ()) } in
        assert { exists q. mem (r.start, eps, q) r.transitions };
        (*assert { delta_ext r.start (Cons eps Nil) r = add r.start r.finalStates };*)
        r
    | Symb a -> let start = next_val c in
        let final = next_val c in
        let states = SS.add start (SS.empty ()) in
        let states = SS.add final states in
        let r = { states = states;
          alphabet = SA.add a (SA.empty ()) ;
          start = start;
          transitions = ST.add (start, a, final) (ST.empty ());
          finalStates = SS.add final (SS.empty ()) } in
        assert { exists q. mem (r.start, a, q) r.transitions };
        (*assert { delta_ext r.start (Cons a Nil) r = r.finalStates };*)
        r
  end

end