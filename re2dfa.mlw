module BasicTypes

  use seq.Seq, list.List

  type char
  
  val eq (c1 c2: char) : bool
    ensures { result <-> c1 = c2 }
    
  val constant eps : char (* used for representing the empty transitions *)

  type string = seq char

  (* defining input symbols and alphabet *)
  type symbol = char

  clone import appset.Appset as SA with type elt = symbol

  (* defining word and language as a set *)
  type word = list symbol

  clone import appset.Appset as SL with type elt = word

  (* defining a state and a set of states *)
  type state = int

  clone import appset.Appset as SS with type elt = state

  (* defining a transition and a set of transitions *)
  type transition = (state , symbol , state)

  clone import appset.Appset as ST with type elt = transition

end


module RegEx

  use BasicTypes
  use list.List

  type regex =
      Empty
    | Eps
    | Symb symbol
    (*| Seq regex regex
    | Plus regex regex*)

  function regexLang (r: regex) : SL.t =
    match r with
    | Empty -> SL.empty
    | Eps -> SL.add (Cons eps Nil) SL.empty
    | Symb a -> SL.add (Cons a Nil) SL.empty
    (*| Seq e f -> let l = regexLang e in
                      SL.iter (fun w -> SL.add w l) Language.add (regexLang f)
    | Plus (e, f) -> Language.union (regexLang f) (regexLang e) <<r*)
   end

end


module NFA

  use BasicTypes, RegEx, ref.Ref
  use int.Int

  type automaton = {
    states: SS.t;
    alphabet: SA.t;
    start: state;
    transitions: ST.t;
    finalStates: SS.t;
  }


  (* --- Compile automaton --- *)
  let c : ref int = ref 0

  let next_val p =
    p := (!p) + 1; !p

  let compile (r: regex) : automaton =
    match r with
    | Empty -> let i = next_val c in
                { states = SS.add i SS.empty; alphabet = SA.empty; start = i; transitions = ST.empty; finalStates = SS.empty }
    | Eps -> let start = next_val c in
              let final = next_val c in
                let states = SS.add start SS.empty in
                  let states = SS.add final states in
                    { states = states; alphabet = SA.empty; start = start; transitions = ST.add (start, eps, final) ST.empty; finalStates = SS.add final SS.empty }
    | Symb a -> let start = next_val c in
                  let final = next_val c in
                    let states = SS.add start SS.empty in
                      let states = SS.add final states in
                        { states = states; alphabet = SA.add a SA.empty ; start = start; transitions = ST.add (start, a, final) ST.empty; finalStates = SS.add final SS.empty }
  end


  (* --- Operations over finite automatons --- *)

  let rec fold_st_to_ss_1st (t: ST.t) (s: SS.t) : SS.t
    variant { ST.cardinal t }
  =
    if ST.is_empty t then s
    else let elem = ST.choose t in
         let (a,_,_) = elem in
         fold_st_to_ss_1st (ST.remove elem t) (SS.add a s)

  let rec fold_st_to_sa (t: ST.t) (s: SA.t) : SA.t
    variant { ST.cardinal t }
  =
    if ST.is_empty t then s
    else let elem = ST.choose t in
         let (_,b,_) = elem in
         fold_st_to_sa (ST.remove elem t) (SA.add b s)

  let rec fold_st_to_ss_3rd (t: ST.t) (s: SS.t) : SS.t
    variant { ST.cardinal t }
  =
    if ST.is_empty t then s
    else let elem = ST.choose t in
         let (_,_,c) = elem in
         fold_st_to_ss_3rd (ST.remove elem t) (SS.add c s)

  (* get starting state, symbol, and/or end state of all transitions in set  *)
  let delta_get_1st (t: ST.t) : SS.t =
    fold_st_to_ss_1st t SS.empty

  let delta_get_2nd (t: ST.t) : SA.t =
    fold_st_to_sa t SA.empty

  let delta_get_3rd (t: ST.t) : SS.t =
    fold_st_to_ss_3rd t SS.empty
  
  
  let rec filter_trans (s: state) (sym: symbol) (t: ST.t) (nt: ST.t) : ST.t 
    variant { ST.cardinal t } 
  =
    if ST.is_empty t then nt
    else let elem = ST.choose t in
         let (a,b,_) = elem in
         if s = a && eq b sym then filter_trans s sym (ST.remove elem t) (ST.add elem nt)
         else filter_trans s sym (ST.remove elem t) nt
  
  (* returns the set of state s and all its states reachable by an epsilon transition, given s and an automaton *)
  let next_eps s t =
    let trans = filter_trans s eps t ST.empty in
      let nextStates = delta_get_3rd trans in	
        SS.add s nextStates

  let rec fold_next_states (s: SS.t) (t: ST.t) (ns: SS.t) : SS.t
    variant { SS.cardinal s }
  =
    if SS.is_empty s then ns
    else let st = SS.choose s in
         let nxt_sts = (next_eps st t) in
         fold_next_states (SS.remove st s) t (SS.union nxt_sts ns)
  
  let rec close_empty sts t = 
    let ns = fold_next_states sts t SS.empty in
      if (SS.subset ns sts) then ns else close_empty (SS.union sts ns) t 

  let eclose (s: state) (a: automaton) =
    close_empty (SS.add s SS.empty) a.transitions
  
  let delta (s: state) (sym: symbol) (t: ST.t) : state =
    let trans = filter_trans s sym t ST.empty in
      delta_get_3rd trans

  let fold_delta (s: SS.t) (sym: symbol) (t: ST.t) (ns: SS.t) : SS.t =
    if s.is_empty then ns
    else let st = SS.choose s in
         let ds = delta st sym t in
         fold_delta (SS.remove st s) sym t (SS.union ds ns)

  let rec eclose_finals (s: SS.t) (t: ST.t) (ns: SS.t) : SS.t =
    if s.is_empty then ns
    else let q = SS.choose s in
         let qs = eclose q t in
         eclose_finals (SS.remove q s) t (SS.union qs ns)

  let rec delta_ext (s: state) (w: word) (a: automaton) : SS.t =
    match w with
    | Nil 
    | Cons eps Nil -> eclose s a (* TODO: a.transtitions *)
    | Cons x xs ->  let rs = delta_ext s xs a in
                    let qs = fold_delta rs x a.transitions in
                    eclose_finals qs a SS.empty (* TODO: a.transitions*)


end